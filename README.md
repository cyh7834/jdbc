# [김영한님] 스프링 DB 1편 - 데이터 접근 핵심 원리
이 강의에서는 JDBC 표준 인터페이스가 등장하게된 배경과 사용법, 그리고 트랜잭션, 예외 처리 시에 많은 클래스에 의존하게 되는 문제점과 해결방안에 대하여 소개한다. 우리가 주로 사용하는 SQL Mapper나 ORM 기술들은 내부적으로 모두 JDBC를 사용한다. 직접 JDBC를 사용하지 않더라도 JDBC가 어떻게 동작하는지 기본 원리를 알아두는 것이 좋고, 문제가 발생했을 때 근본적인 문제를 찾아서 해결할 수 있기 때문에 이 강의를 구매하게 됐다.

## 배운점
- JDBC의 등장으로 해결된 문제들<br/>
데이터베이스를 변경 시에 애플리케이션 서버의 데이터베이스 사용 코드도 함께 변경해야하는 문제와 개발자가 각각의 데이터베이스마다 connection 연결, SQL 전달, 그리고 결과 값 처리 등을 새로 학습해야하는 문제가 해결되었다.

- JDBC DriverManager connection 요청 흐름<br/>
DriverManager.getConnection()을 호출하여 데이터베이스 연결 URL에 적합한 드라이버를 찾아 반환한다.

- DataSource 인터페이스 등장 이유<br/>
DataSource는 connection 객체를 획득하는 방법을 추상화하여 인터페이스로 제공한다. connection pool은 실무에선 필수적으로 사용한다. 개발 도중 connection pool을 변경하고자 할때, 각 connection pool의 DataSource 구현체만 변경하면 되기 때문에 편리하다.

- 트랜잭션과 락의 개념 복습

- 단순 JDBC 트랜잭션 사용의 문제점과 해결방안<br/>
트랜잭션은 서비스 로직에서 수행돼야하고 connection 객체를 유지시켜야 하기 때문에 서비스 계층이 지저분해지고 복잡한 의존 관계를 가지게 된다. 스프링이 제공하는 PlatformTransactionManager 인터페이스는 JDBC나 JPA 등의 트랜잭션을 추상화와 리소스 동기화를 제공한다. PlatformTransactionManager 인터페이스를 통해 추후에 데이터베이스 변경 시 트랜잭션 관련 코드를 변경하지 않아도 되고, 리소스 동기화를 통해 서비스 계층이 connection 객체에 직접적인 의존을 하지 않게 되고, 데이터 접근 계층으로 전달하지 않아도 된다. 또한 @Transactional 어노테이션을 통해 서비스 로직에서 쿼리 commit과 rollback을 직접적으로 처리하지 않아도 되기 때문에 결합도를 낮출 수 있다.

- 체크 예외, 언체크 예외<br/>
체크 예외는 필수적으로 잡아서 직접 처리하거나, 상위 콜 스택으로 던지도록 선언해야한다. 그렇지 않으면 컴파일 오류가 발생한다. 체크 예외는 컴파일러를 통해 예외 누락 여부를 알 수 있기 때문에 안전하지만, 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야하고, 예외에 따른 의존 관계도 생긴다. 반대로 언체크 예외는 밖으로 던지는 예외 선언을 생략할 수 있다. 

- 언체크 예외 활용 방식<br/>
JDBC를 사용하면서 여러 계층으로 의존되던 체크 예외를 에러 스택을 포함하여 언체크 예외로 처리하는 방식을 통해 여러 계층의 의존 관계를 해결하는 방식에 대해 알게됐다.
